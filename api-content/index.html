{"posts":[{"title":"博客嵌入自适应 B 站视频","content":"如何嵌入 B 站视频 B 站的网页版已经提供了内嵌的 iframe 代码，我们只需要一键复制后就可以直接使用。 外链的引用方式 但是 B 站提供的外链在页面上显示经常是&quot;残废版&quot;，而且不能调节清晰度、弹幕之类的，也不能全屏，非常影响体验。 原版链接 &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=328334002&amp;bvid=BV1tA411q7xi&amp;cid=193834244&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt; 增大版本 于是就想给它增大一下，也就是用 html 的方式调一下 width 和 height 的大小。 &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=328334002&amp;bvid=BV1tA411q7xi&amp;cid=193834244&amp;page=1&quot; frameborder=&quot;no&quot; scrolling=&quot;no&quot; width=&quot;95%&quot; height=&quot;600&quot;&gt;&lt;/iframe&gt;&lt;/iframe&gt; 这样其实一般来说是够用了，但是它也有问题，就是移动端适配非常差，我们能不能搞一种更通用的引用方式呢？ 自适应版 前面引那么多就是为了给出最后这个结论，当然是可以实现自适应的，代码如下， &lt;div style=&quot;position: relative; padding: 30% 45%;&quot;&gt; &lt;iframe style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot; src=&quot;//player.bilibili.com/player.html?aid=52516662&amp;bvid=BV1o4411E7xW&amp;cid=91907659&amp;page=1&amp;as_wide=1&amp;high_quality=1&amp;danmaku=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; 参数说明： key 说明 aid 之前 B 站使用的 AV 号 bvid 目前的 BV 号 page 第几个视频, 起始下标为 1 (默认值也是为 1)就是 B 站视频, 选集里的, 第几个视频 as_wide 是否宽屏 【1: 宽屏, 0: 小屏】 high_quality 是否高清 【1: 高清(最高1080p) / 0: 最低视频质量(默认)】 danmaku 是否开启弹幕 【1: 开启(默认), 0: 关闭】 相关信息： 经测试 high_quality 参数可以正常使用，此参数控制外链播放器的默认清晰度： =1 时默认清晰度是最高非大会员清晰度，例如： （1）原视频清晰度有 360p、480p、720p，外链播放器默认为最高的 720p， （2）原视频清晰度有 360p、480p、720p、1080p，外链播放器默认为最高的 1080p， （3）原视频清晰度有 360p、480p、720p、1080p、1080p+，外链播放器默认为 1080p， 选择其他清晰度会打开原视频页面， 注本文引用 https://bestzuo.cn/posts/blog-bilbli.html 该文章，如有侵权请联系删除。 ","link":"https://note.iqtian.com/post/OX3rttR5U/"},{"title":"Nginx反向代理后端获取客户端真实IP","content":"Nginx反向代理后，Servlet应用通过request.getRemoteAddr()取到的IP是Nginx的IP地址，并非客户端真实IP，通过request.getRequestURL()获取的域名、协议、端口都是Nginx访问Web应用时的域名、协议、端口，而非客户端浏览器地址栏上的真实域名、协议、端口。 Nginx的反向代理实际上是客户端和真实的应用服务器之间的一个桥梁，客户端（一般是浏览器）访问Nginx服务器，Nginx再去访问Web应用服务器。对于Web应用来说，这次HTTP请求的客户端是Nginx而非真实的客户端浏览器，如果不做特殊处理的话，Web应用会把Nginx当作请求的客户端，获取到的客户端信息就是Nginx的一些信息。 解决这个问题要从两个方面来解决： 由于Nginx是代理服务器，所有客户端请求都从Nginx转发到Tomcat，如果Nginx不把客户端真实IP、域名、协议、端口告诉Tomcat，那么Tomcat应用是永远不会知道这些信息的，所以需要Nginx配置一些HTTP Header来将这些信息告诉被代理的Tomcat； Tomcat这一端，不能再傻乎乎的获取直接和它连接的客户端（也就是Nginx）的信息，而是要从Nginx传递过来的HTTP Header中获取客户端信息。 废话不多说直接上配置 在代理的每个location处添加以下配置： proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; 解释以下上面的配置，以上配置是在Nginx反向代理的时候，添加一些请求Header。 Host包含客户端真实的域名和端口号； X-Forwarded-Proto表示客户端真实的协议（http还是https）； X-Real-IP表示客户端真实的IP； X-Forwarded-For这个Header和X-Real-IP类似，但它在多层代理时会包含真实客户端及中间每个代理服务器的IP。 配置到这一步后，还不能彻底解决问题。tomcat也需要配置 如果你在网上搜索“Java如何获取客户端真实IP”，搜索到的解决方案大多是通过获取HTTP请求头request.getHeader(&quot;X-Forwarded-For&quot;)或request.getHeader(&quot;X-Real-IP&quot;)来实现，也就是上面在Nginx上配置的Header，这种方案获取的结果的确是正确的，但觉得并不优雅。因为既然Servlet API提供了request.getRemoteAddr()方法获取客户端IP，那么无论有没有用反向代理对于代码编写者来说应该是透明的。下面介绍一种更加优雅的方式。 使用Tomcat作为应用服务器，可以通过配置Tomcat的server.xml文件，在Host元素内最后加入：即可 &lt;Valve className=&quot;org.apache.catalina.valves.RemoteIpValve&quot; /&gt; ","link":"https://note.iqtian.com/post/EqmcpNqS9/"},{"title":"Centos7 firewalld 防火墙配置","content":"Centos7防火墙开放端口、删除端口、查看已开放的端口等 Centos7默认安装了firewalld，如果没有安装的话，则需要YUM命令安装；firewalld真的用不习惯，与之前的iptable防火墙区别太大，但毕竟是未来主流讲究慢慢磨合它的设置规则； 安装Firewall命令： yum install firewalld firewalld-config Firewall开启常见端口命令： firewall-cmd --zone=public --add-port=80/tcp --permanent firewall-cmd --zone=public --add-port=443/tcp --permanent firewall-cmd --zone=public --add-port=22/tcp --permanent firewall-cmd --zone=public --add-port=21/tcp --permanent firewall-cmd --zone=public --add-port=53/udp --permanent Firewall关闭常见端口命令： firewall-cmd --zone=public --remove-port=80/tcp --permanent firewall-cmd --zone=public --remove-port=443/tcp --permanent firewall-cmd --zone=public --remove-port=22/tcp --permanent firewall-cmd --zone=public --remove-port=21/tcp --permanent firewall-cmd --zone=public --remove-port=53/udp --permanent 批量添加区间端口 firewall-cmd --zone=public --add-port=4400-4600/udp --permanent firewall-cmd --zone=public --add-port=4400-4600/tcp --permanent 开启防火墙命令： systemctl start firewalld.service 重启防火墙命令： firewall-cmd --reload 或者 service firewalld restart 查看端口列表： firewall-cmd --permanent --list-port 禁用防火墙 systemctl stop firewalld 设置开机启动 systemctl enable firewalld 停止并禁用开机启动 sytemctl disable firewalld 查看状态 systemctl status firewalld # 或者 firewall-cmd --state ","link":"https://note.iqtian.com/post/zZ8m-9eWA/"},{"title":"Docker配置加速pull镜像","content":"加速拉取镜像 在国内拉取Docker注册表上的镜像时考虑到国内的互联网环境（网络因素，被墙等）会拉取失败或者贼慢的情况我们需要给Docker配置一下pull加速 配置加速 第一种是使用国内阿里云提供的容器服务里的加速 针对Docker客户端版本大于 1.10.0 的用户 您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF' { &quot;registry-mirrors&quot;: [&quot;https://aijuoso5.mirror.aliyuncs.com&quot;] } EOF sudo systemctl daemon-reload sudo systemctl restart docker 这里的https://aijuoso5.mirror.aliyuncs.com是我的加速地址你可以登录自己的阿里云容器镜像服务控制台查看自己的地址是：https://cr.console.aliyun.com/cn-hangzhou/instances/repositories 第二种是使用DaoCloud的加速 同上面阿里云的一样只需要改加速地址即可 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF' { &quot;registry-mirrors&quot;: [&quot;http://f1361db2.m.daocloud.io&quot;] } EOF sudo systemctl daemon-reload sudo systemctl restart docker 也可以使用命令直接就可以自动给你配置好 curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io # 这个命令对Centos8不太友好 至此你pull镜像速度上会快很多 ","link":"https://note.iqtian.com/post/xIrNCbMk8/"},{"title":"Docker Compose安装Gitlab","content":"Docker Compose安装Gitlab Gitlab总共有两个版本一个是社区版一个是企业版，两个版本功能上基本没区别但企业版要去Gitlab官方买授权证书要花钱所以我们选择社区版已经够用了的基本上满足中小型企业及个人 我们登录服务器创建Gitlab目录及docker-compose.yml mkdir gitlab cd gitlab touch docker-compose.yaml 配置文件 docker-compose.yml配置文件 version: '3.3' services: gitlab: image: 'gitlab/gitlab-ce:latest' container_name: 'gitlab' restart: always hostname: 'gitlab' #填写计算机名即可 environment: TZ: 'Asia/Shanghai' GITLAB_OMNIBUS_CONFIG: | external_url 'https://mqthub.com' #访问地址 # HTTPS配置 nginx['enable'] = true nginx['redirect_http_to_https']= true nginx['ssl_certificate']= &quot;/home/cert/mqthub.com/mqthub.com.pem&quot; nginx['ssl_certificate_key']= &quot;/home/cert/mqthub.com.com/mqthub.com.key&quot; # 端口配置 gitlab_rails['gitlab_shell_ssh_port'] = 2222 unicorn['port'] = 8880 # Email配置 gitlab_rails['smtp_enable'] = true gitlab_rails['smtp_address'] = &quot;smtp.exmail.qq.com&quot; gitlab_rails['smtp_port'] = 465 gitlab_rails['smtp_user_name'] = &quot;noreply@mqtian.com&quot; gitlab_rails['smtp_password'] = &quot;xxx&quot; gitlab_rails['smtp_authentication'] = &quot;login&quot; gitlab_rails['smtp_enable_starttls_auto'] = true gitlab_rails['smtp_tls'] = true gitlab_rails['gitlab_email_from'] = 'noreply@mqtian.com' ports: - '80:80' #http端口 - '443:443' #https端口 - '222:22' #配置222端口转发到容器的22端口上 volumes: - ./etc:/etc/gitlab #Gitlab配置文件目录 - ./data:/var/opt/gitlab #Gitlab数据目录 - ./logs:/var/log/gitlab #Gitlab日志目录 - ~/cert/:/home/cert/ #域名SSL证书目录 - /etc/localtime:/etc/localtime:ro #同步宿主机日期时间到容器 启动Gitlab docker-compose up -d # 启动 docker-compose stop # 停止 docker-compose start # 启动 docker-compose restart # 重启 docker-compose down # 停止容器并移除 访问Gitlab 我们安装完Gitlab后第一次访问会重定向到root用户重置密码界面重置完密码后使用root+刚刚设置的密码登录即可 我的Gitlab是配置了Github账号快速登录的如需要配置的话请邮件@我 我的邮件：mqtian@outlook.com 或者 hi@mqtian.com ","link":"https://note.iqtian.com/post/HZ6l2rZVr/"},{"title":"Docker Compose安装jenkins","content":"Docker Compose安装jenkins 登录服务器并创建jenkins所需要的目录 mkdir jenkins cd jenkins touch docker-compose.yaml mkdir data 配置文件 docker-compose.yml配置文件 jenkins: image: jenkins/jenkins:lts volumes: - ./data/jenkins/:/var/jenkins_home - /var/run/docker.sock:/var/run/docker.sock - /usr/bin/docker:/usr/bin/docker - ./usr/lib/x86_64-linux-gnu/libltdl.so.7:/usr/lib/x86_64-linux-gnu/libltdl.so.7 ports: - &quot;2027:8080&quot; expose: - &quot;8080&quot; - &quot;50000&quot; privileged: true user: root restart: always container_name: jenkins environment: JAVA_OPTS: '-Djava.util.logging.config.file=/var/jenkins_home/log.properties' 启动jenkins docker-compose up -d # 启动 docker-compose stop # 停止 docker-compose start # 启动 docker-compose restart # 重启 docker-compose down # 停止容器并移除 权限问题 jenkins启动成功后日志会出现报错那是因为权限问题导致的我们需要给data目录权限 chown -R 1000:1000 /data/jenkins 解决完之后我们访问jenkins服务器IP+端口访问 解锁jenkins密钥如下命令会输出密钥复制到jenkins并点击继续即可 cat /data/jenkins/secrets/initialAdminPassword 如果上面的查看密钥方法没找到的话可以进入容器内查看 docker exec -it jenkins bash cat /var/jenkins_home/secrets/initialAdminPassword 往后就是基础操作了下一步进行插件安装然后再创建用户即可 ","link":"https://note.iqtian.com/post/njgg20QZC/"},{"title":"Docker Compose安装Redis","content":"Docker Compose安装Redis 登录服务器并创建redis目录及redis配置文件 mkdir redis cd redis touch docker-compose.yaml touch redis.conf 配置文件 docker-compose.yml配置文件 version: &quot;3.3&quot; services: redis: image: &quot;redis:latest&quot; container_name: redis-pord restart: always ports: - &quot;6379:6379&quot; volumes: - ./redis.conf:/etc/redis/redis.conf:rw - ./data:/data:rw command: # 执行的命令 redis-server /etc/redis/redis.conf --appendonly yes redis.conf配置文件 requirepass 123456 appendonly yes 启动Redis docker-compose up -d # 启动 docker-compose stop # 停止 docker-compose start # 启动 docker-compose restart # 重启 docker-compose down # 停止容器并移除 测试连接Redis 使用服务器IP加6379及Redis密码即可访问Redis了 Redis Windows版客户端下载地址 https://github.com/qishibo/AnotherRedisDesktopManager/releases ","link":"https://note.iqtian.com/post/4wvNnZBoi/"},{"title":"Docker Compose安装Tomcat","content":"Docker Compose安装Tomcat 登录服务器并创建 conf docker-compose.yaml conf是目录Tomcat的配置文件目录后一个是文件。 mkdir tomcat mkdir conf touch docker-compose.yaml cd conf touch server.xml 配置文件 docker-compose.yaml配置文件 version: &quot;3&quot; services: tomcat: image: &quot;daocloud.io/library/tomcat:8.5.15-jre8&quot; restart: always container_name: tomcat ports: - 8080:8080 volumes: - ./conf/server.xml:/usr/local/tomcat/conf/server.xml - ./logs:/usr/local/tomcat/logs #- ./webapps://usr/local/tomcat/webapps/ # 发布war包时把注释删掉并在tomcat跟目录下创建webapps目录用于上传war包 - /etc/localtime:/etc/localtime:ro 解释: 端口映射前面的端口是宿主机的端口后面是容器的端口如要改tomcat端口只需要改前面的宿主机端口即可不用改容器的（改容器的端口需要同步把serve.xml内的端口也改了） ports: - 8080:8080 下面的目录分别是tomcat配置文件目录webapps项目发布目录logs日志目录 conf webapps logs 启动Tomcat docker-compose up -d # 启动 docker-compose stop # 停止 docker-compose start # 启动 docker-compose restart # 重启 docker-compose down # 停止容器并移除 ","link":"https://note.iqtian.com/post/JLSTaagax/"},{"title":"Docker Compose安装Nginx","content":"Docker Compose安装Nginx 为什么要使用Docker Compose安装Nginx，因为Docker方便管理及配置环境等只需要一次即可发布多个环境例如：开发环境、测试环境、生产环境等。 接下来我们需要登录服务器并创建docker-compose.yml及目录： 本 Nginx 部署的是带 HTTPS 的需要创建 cert 证书目录在 root 目录下创建即可(当然不一定要在root目录下创建可以在其他路径创建后面再docker-compose.yml文件内指定即可) 这里默认登录的是root用户则直接在root用户的家目录下创建证书目录 mkdir cert # 用于存放域名证书 创建站点目录同样在root用户家目录也可以在其他地方创建后面改docker-compose.yml文件内的路径即可（web下面目录） mkdir www 下面创建Nginx目录 mkdir nginx cd nginx mkdir conf.d touch docker-compose.yaml # docker-compose文件 touch nginx.conf # Nginx全局配置文件 cd conf.d # 站点配置目录 touch default.conf # 这个文件是站点配置文件及一个站点 目录截图 编写配置文件 docker-compose.yml配置文件 vim docker-compose.yaml version: &quot;3&quot; services: nginx: image: nginx ports: - 80:80 - 443:443 volumes: - ~/cert:/home/cert # HTTPS证书目录挂载到容器的home目录下 - ~/www:/home/www # 挂载宿主机上的www目录到容器里的home目录下方便发布web项目 - ./nginx.conf:/etc/nginx/nginx.conf - ./conf.d/:/etc/nginx/conf.d/ - ./logs:/var/log/nginx # 把容器内的Nginx日志目录挂载到宿主机 #- ~/download:/home/download - /etc/localtime:/etc/localtime:ro #配置容器时间同步 restart: always container_name: nginx nginx.conf配置文件 vim nginx.conf user nginx; worker_processes 2; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] &quot;$request&quot; ' '$status $body_bytes_sent &quot;$http_referer&quot; ' '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; # 开启和关闭gzip模式 gzip on; # gizp压缩起点，文件大于1k才进行压缩 gzip_min_length 1k; # gzip 压缩级别，1-9，数字越大压缩的越好，也越占用CPU时间 gzip_comp_level 9; # 进行压缩的文件类型。 gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; # nginx对于静态文件的处理模块，开启后会寻找以.gz结尾的文件，直接返回，不会占用cpu进行压缩，如果找不到则不进行压缩 gzip_static on; # 是否在http header中添加Vary: Accept-Encoding，建议开启 gzip_vary on; # 设置压缩所需要的缓冲区大小，以4k为单位，如果文件为7k则申请2*4k的缓冲区 gzip_buffers 2 4k; # 设置gzip压缩针对的HTTP协议版本 gzip_http_version 1.1; # 禁用IE 6 gzip gzip_disable &quot;MSIE [1-6]\\.&quot;; include /etc/nginx/conf.d/*.conf; # 跨域配置 #add_header Access-Control-Allow-Origin *; #add_header Access-Control-Allow-Headers X-Requested-With; #add_header Access-Control-Allow-Methods GET,POST,OPTIONS; #server { # 配置IP跟未在conf.d目录下配置过站点的域名访问直接返回403 #listen 80 default_server; #listen 443 ssl default_server; #server_name _; #ssl_certificate /home/cert/nikouer.com/nikouer.com.pem; #ssl_certificate_key /home/cert/nikouer.com/nikouer.com.key; #ssl_session_cache shared:SSL:1m; #ssl_session_timeout 5m; #ssl_ciphers HIGH:!aNULL:!MD5; #ssl_prefer_server_ciphers on; #return 403; #} } default.conf配置文件 vim conf.d/default.conf server { listen 80; server_name mqtian.com www.mqtian.com; # 配置访问的域名（站点域名） rewrite ^(.*) https://$server_name$1 permanent; # HTTP--&gt;HTTPS 即访问80端口时自动跳转443端口 } server { listen 443 ssl; server_name mqtian.com www.mqtian.com; charset utf-8; access_log /var/log/nginx/mqtian.com.log; # 自定义日志输出 ssl_certificate /home/cert/mqtian.com/mqtian.com.pem; # SSL证书路径 ssl_certificate_key /home/cert/mqtian.com/mqtian.com.key; # SSL证书路径 ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / { #proxy_pass http://10.0.4.14:8662; # 后端地址 #client_max_body_size 10M; #add_header Content-Security-Policy upgrade-insecure-requests; # 给站点http来源强制改变为https来源 #proxy_set_header Host $http_host; # Host包含客户端真实的域名和端口号 #proxy_set_header X-Real-IP $remote_addr; # X-Forwarded-Proto表示客户端真实的协议（http还是https） #proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # X-Real-IP表示客户端真实的IP #proxy_set_header X-Forwarded-Proto $scheme; root /usr/share/nginx/html; # 发布web项目的目录 index index.html index.html; } error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } 启动Nginx docker-compose up -d # 启动 docker-compose stop # 停止 docker-compose start # 启动 docker-compose restart # 重启 docker-compose down # 停止容器并移除 接下来就访问试试把 访问刚刚部署的域名站点 https://mqtian.com ","link":"https://note.iqtian.com/post/x407Ei7Gs/"},{"title":"Linux系统安装Docker Compose及使用","content":"Docker Compose 简介 Docker Compose 是一种用于通过使用单个命令创建和启动 Docker 应用程序的工具。我们可以使用它来配置应用程序的服务。 它是开发，测试和升级环境的利器。 它提供以下命令来管理应用程序的整个生命周期： 启动，停止和重建服务 查看运行服务的状态 流式运行服务的日志输出 在服务上运行一次性命令 要实现 docker compose，需要包括以下步骤： 将应用程序环境变量放在 Docker 文件中以公开访问。 在 docker-compose.yml 文件中提供和配置服务名称，以便它们可以在隔离的环境中一起运行。 运行 docker-compose 将启动并运行整个应用程序。 Docker Compose 安装 以下是在 Ubuntu 系统中安装 Docker Compose 的(具体各版本linux可以手动去Github下载然后上传服务器即可)： curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose 以下是下载进度： 如果下载时间过长或者下载失败可以手动去Github下载 https://github.com/docker/compose/releases最新版即可下载完之后上传服务器 /usr/local/bin/目录下并给予执行权限 chmod +x /usr/local/bin/docker-compose 给你上传的docker-compose文件执行权限 如下图 验证Docker Compose版本 docker-compose version 使用Docker compose部署一个Tomcat 创建一个名为Tomcat的目录并在下新建docker-compose.yml文件 mkdir tomcat cd tomcat touch docker-compose.yaml vim docker-compose.yaml docker-compose.yaml内容： version: '3' services: tomcat: restart: always image: tomcat container_name: tomcat ports: - 8000:8000 参数说明： version：指定脚本语法解释器版本 services：要启动的服务列表 webapp：服务名称，可以随便起名，不重复即可 restart：启动方式，这里的 always 表示总是启动，即使服务器重启了也会立即启动服务 image：镜像的名称，默认从 Docker Hub 下载 container_name：容器名称，可以随便起名，不重复即可 ports：端口映射列列表，左边为宿主机端口，右边为容器端口 Docker Compose常用命令 命令 解释 docker-compose pull 拉取docker-compose.yml文件内编排的服务镜像（自定义的镜像除外因为Docker注册表上没你自定义的镜像） docker-compose up 前台运行 如果中断终端时你的服务就会停止运行了 docker-compose up -d 后台启动 docker-compose stop 停止 docker-compose start 启动 docker-compose restart 重启 docker-compose ps 查看docker-compose.yml内编排的服务是否在运行与docker ps相同 docker-compose down 停止并移除容器 访问刚刚部署的Tomcat 使用服务器IP+8080端口就可以访问你部署的Tomcat了 ","link":"https://note.iqtian.com/post/kjPm5W4ox/"},{"title":"Centos7安装Docker","content":"Docker简介 Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。 Docker 使用客户端-服务器 (C/S) 架构模式 使用远程API来管理和创建Docker容器。Docker 容器（Container）通过 Docker 镜像（Image）来创建，二者之间的关系类似于面向对象编程中的对象与类 那Docker由什么组成呢， 包括三个基本概念: 仓库（Repository） 镜像（Image） 容器(Container） 其中Registry是Docker用于存放镜像文件的仓库，Docker 仓库的概念跟Git 类似（就像商店存放所有的英雄，只是更改英雄的权限在某些非程序员手里）。 所谓镜像就是构建容器的源代码，是一个只读的模板，由一层一层的文件系统组成的，类似于虚拟机的镜像（英雄也是只读的，有自己的技能被动，你也不能进行操作）。 那么容器就是由Docker镜像创建的运行实例，类似于虚拟机，容器之间是相互隔离的，包含特定的应用及其所需的依赖文件（好比每个英雄都是隔离的，都有自己的皮肤，技能以及走的路线)。 注：Docker Hub是Docker公司提供的一个注册服务器（Register）来保存多个仓库，每个仓库又可以包含多个具备不同tag的镜像。 安装Docker Centos7，linux 3.10 内核，docker官方说至少3.8以上，建议3.10以上（ubuntu下要linux内核3.8以上， RHEL/Centos 的内核修补过， centos6.5的版本就可以——这个可以试试） root账户登录，查看内核版本如下 uname -a 把yum包更新到最新 yum update # 期间要选择确认，输入 y 即可 安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 yum install -y yum-utils device-mapper-persistent-data lvm2 设置yum源（选择其中一个） yum-config-manager --add-repo http://download.docker.com/linux/centos/docker-ce.repo（中央仓库）# Docker官方的 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo（阿里仓库）# 阿里云的速度在国内速度快 yum-config-manager --add-repo # 设置完yum源后执行 可以查看所有仓库中所有docker版本，并选择特定版本安装 yum list docker-ce --showduplicates | sort -r 安装Docker，命令：yum install docker-ce yum install -y docker-ce #或者 yum install -y docker-ce-18.03.1.ce # 安装指定版本 启动Docker systemctl start docker # 启动Docker systemctl enable docker # 设置开机启动 查看版本 docker version # 执行后输出Docker版本信息 Docker常用命令 命令 解释 docker pull nginx:latest 拉取nginx镜像也可以换成要拉取的其他镜像 docker images 查看拉取好的所有镜像 docker run -d nginx -p 80:80 --name nginx nginx:latest 运行Nginx -p 80:80 映射容器80端口到宿主机80端口 --name nginx 是给该容器起一个别名，最后是运行的镜像 Nginx docker run -d nginx -p 80:80 -v /www:/www --name nginx nginx:latest -v /www:/www 是挂载宿主机 /www 目录到容器里作用是发布web项目 docker run -d nginx -p 80:80 -v /www:/www -e --name nginx nginx:latest -e 可以传递你在Dockerfile文件里配置的变量, 传递环境变量 适用于自定义的镜像 docker stop nginx 停止运行别名为 nginx 的容器 docker start nginx 启动别名为 nginx 的容器 docker restart nginx 重新启动别名为 nginx 的容器 docker ps 查看已停止运行的容器 docker ps -a -a 显示所有的容器，包括未运行的 docker ps -f -f 根据条件过滤显示的内容 docker --format --format 指定返回值的模板文件 docker ps -l -l 显示最近创建的容器 docker ps -1 -q 静默模式，只显示容器编号 docker ps -s -s 显示总的文件大小 docker rm nginx 删除已停止运行的nginx docker rmi nginx 删除nginx镜像 docker run -d --name selenium_hub selenium/hub docker run -d --name node --link selenium_hub:hub selenium/node-chrome-debug 创建并启动名为node的容器，并把该容器和名为selenium_hub的容器链接起来。 ","link":"https://note.iqtian.com/post/B10wKysO4/"},{"title":"Docker部署MySQL5.7","content":"Docker部署MySQL5.7 新建一个目录用于存放docker-compose.yml文件 mkdir mysql cd mysql touch docker-compose.yml docker-compose.yml文件内容如下： version: '3.3' services: mysql: hostname: mysql # 启动容器名称mysql container_name: mysql # 使用mysql 5.7.20的镜像 image: mysql:5.7.28 # 自启动 restart: always command: # mysql默认使用utf8mb4编码 - --character-set-server=utf8mb4 - --collation-server=utf8mb4_general_ci # mysql时间加8个小时 - --default-time_zone=+8:00 environment: # 服务器时区使用上海 TZ: Asis/Shanghai # mysql初始化密码 MYSQL_ROOT_PASSWORD: 1111 ports: # 容器3306端口映射到宿主机3306端口 - &quot;1120:3306&quot; volumes: # mysql相关数据存储在宿主机/data/docker/mysql文件夹 - &quot;./data/:/var/lib/mysql&quot; 拉取MySQL5.7.28镜像 docker pull mysql:5.7.28 当然你也可以直接运行docker-compose up -d他会在运行时拉镜像 运行MySQL docker-compose up -d # 后台运行 docker-compose down # 停止运行 docker-compose restart # 重新启动 docker-compose stop # 停止运行（不会删除运行记录） docker-compose start # 恢复运行 使用MySQL客户端连接MySQL 这里使用sqlyog连接 至此MySQL已经部署完毕 ","link":"https://note.iqtian.com/post/2-qt8P0g6/"},{"title":"Hello world","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://note.iqtian.com/post/hello-world/"}]}